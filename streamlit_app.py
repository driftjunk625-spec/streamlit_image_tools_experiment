# Print-a-GIF â€” Streamlit App (Version C+)# Grid layout (even spacing like Version C) + Row Layout Mode (from D.2)## Highlights# - Even grid: rows Ã— columns, equal cell sizes, tidy spacing# - Per-frame cut box inside each cell:#     * uniform cut margin on 3 sides#     * binding side gets (cut margin + binding extra)# - Binding-aware placement: image flushes opposite the bound edge# - Cut marks draw the per-frame cut box (all 4 edges)# - Border mode: Frame box (cut area) / Cell box / Both / None# - Row layout mode:#     * Fixed columns (no auto-scale): keep C behavior (fit-to-box Ã— user scale or lock @100%)#     * Fit N per row (auto): ignore lock & user scale; resize to FIT the inner box (no crop)# - A4/custom, DPI, PDF export, ZIPsfrom __future__ import annotationsimport ioimport zipfilefrom dataclasses import dataclass, fieldfrom typing import List, Tuplefrom PIL import Image, ImageDraw, ImageFont, ImageSequencefrom reportlab.pdfgen import canvas as pdf_canvasimport streamlit as st# ------------------------------- Utilities ------------------------------- #MM_PER_INCH = 25.4def mm_to_px(mm_val: float, dpi: float) -> int:    return int(round(mm_val / MM_PER_INCH * dpi))def hex_to_rgb(hex_color: str) -> Tuple[int, int, int]:    hex_color = hex_color.lstrip('#')    if len(hex_color) == 6:        return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))    raise ValueError("Expected 6-digit hex color like #RRGGBB")@dataclassclass PageSpec:    width_mm: float    height_mm: float    orientation: str  # 'portrait' | 'landscape'    dpi: int    @property    def width_px(self) -> int:        w_mm, h_mm = (self.width_mm, self.height_mm)        if self.orientation == 'landscape':            w_mm, h_mm = (self.height_mm, self.width_mm)        return mm_to_px(w_mm, self.dpi)    @property    def height_px(self) -> int:        w_mm, h_mm = (self.width_mm, self.height_mm)        if self.orientation == 'landscape':            w_mm, h_mm = (self.height_mm, self.width_mm)        return mm_to_px(h_mm, self.dpi)    @property    def pagesize_pts(self) -> Tuple[float, float]:        w_in = (self.width_mm / MM_PER_INCH)        h_in = (self.height_mm / MM_PER_INCH)        if self.orientation == 'landscape':            w_in, h_in = h_in, w_in        return (w_in * 72.0, h_in * 72.0)# ------------------------- GIF Frame Extraction -------------------------- #def coalesce_gif(im: Image.Image) -> List[Image.Image]:    frames: List[Image.Image] = []    previous = Image.new('RGBA', im.size, (0, 0, 0, 0))    palette = im.getpalette()    for frame in ImageSequence.Iterator(im):        if frame.mode == 'P':            if not frame.getpalette() and palette is not None:                frame.putpalette(palette)            else:                palette = frame.getpalette()            frame_rgba = frame.convert('RGBA')        else:            frame_rgba = frame.convert('RGBA')        composed = Image.alpha_composite(previous, frame_rgba)        frames.append(composed)        previous = composed    return framesdef extract_gif_frames(file_bytes: bytes, unoptimize: bool) -> List[Image.Image]:    with Image.open(io.BytesIO(file_bytes)) as im:        if unoptimize:            return coalesce_gif(im)        else:            return [f.convert('RGBA') for f in ImageSequence.Iterator(im)]# ----------------------------- Layout Params ----------------------------- #@dataclassclass LayoutParams:    # Grid    cols: int    rows: int    # Page & gutters    print_margin_mm: float            # outer page margin    cut_spacing_mm: float             # spacing between cells    # Optional page binding tab (strip outside grid)    tab_width_mm: float    tab_side: str                     # 'left'|'right'|'top'|'bottom'|'none'    # Appearance    spacing_hex: str    draw_guides: bool    draw_numbers: bool    number_font_size_pt: int    # Image sizing    lock_original_scale: bool = field(default=False)    frame_scale_pct: int = field(default=100)   # 10â€“200, ignored when lock_original_scale    # Per-frame cut box (inside each cell)    frame_margin_mm: float = field(default=3.0)       # all sides    frame_binding_extra_mm: float = field(default=3.0) # added on bound side only    # Cut marks    show_cut_marks: bool = field(default=True)    cut_mark_len_mm: float = field(default=4.0)    cut_mark_offset_mm: float = field(default=0.0)    cut_mark_width_px: int = field(default=1)    # Borders    show_frame_border: bool = field(default=False)    show_cell_border: bool = field(default=False)    border_color_hex: str = field(default="#000000")    border_width_px: int = field(default=1)    # Row Layout Mode    fit_to_columns: bool = field(default=False)  # when True: auto-scale to fit inner cut box (ignores lock & user scale)# --------------------------- Page Composition ---------------------------- #def compose_pages(frames: List[Image.Image], page: PageSpec, layout: LayoutParams) -> List[Image.Image]:    W, H = page.width_px, page.height_px    margin_px = mm_to_px(layout.print_margin_mm, page.dpi)    spacing_px = mm_to_px(layout.cut_spacing_mm, page.dpi)    tab_px = mm_to_px(layout.tab_width_mm, page.dpi) if layout.tab_side != 'none' else 0    # Content area (symmetric margins)    content_x = margin_px    content_y = margin_px    content_w = W - 2 * margin_px    content_h = H - 2 * margin_px    # Page-level tab strip (outside grid)    if layout.tab_side == 'left':        content_x += tab_px        content_w -= tab_px    elif layout.tab_side == 'right':        content_w -= tab_px    elif layout.tab_side == 'top':        content_y += tab_px        content_h -= tab_px    elif layout.tab_side == 'bottom':        content_h -= tab_px    cols = max(1, layout.cols)    rows = max(1, layout.rows)    # Equal cell sizes, like Version C    cell_w_f = (content_w - (cols - 1) * spacing_px) / cols    cell_h_f = (content_h - (rows - 1) * spacing_px) / rows    # Integer grid bounds (snap last row/col to edges to remove drift)    spacing_int = int(spacing_px)    col_bounds: List[Tuple[int, int]] = []    x = int(content_x)    for c in range(cols):        if c == cols - 1:            x1 = int(content_x + content_w)        else:            x1 = x + int(round(cell_w_f))        col_bounds.append((x, x1))        x = x1 + spacing_int    row_bounds: List[Tuple[int, int]] = []    y = int(content_y)    for r in range(rows):        if r == rows - 1:            y1 = int(content_y + content_h)        else:            y1 = y + int(round(cell_h_f))        row_bounds.append((y, y1))        y = y1 + spacing_int    bg_rgb = hex_to_rgb(layout.spacing_hex)    page_images: List[Image.Image] = []    def scale_to_inner_box(im: Image.Image, rw: int, rh: int) -> Image.Image:        # Fit EITHER by C behavior or auto-fit mode        if layout.fit_to_columns:            # Auto-fit: ignore lock & user scale; fit fully within inner box (no crop)            iw, ih = im.size            s = min(rw / iw, rh / ih)            new_w = max(1, int(iw * s))            new_h = max(1, int(ih * s))            return im.resize((new_w, new_h), Image.LANCZOS)        else:            if layout.lock_original_scale:                return im            iw, ih = im.size            fit_scale = min(rw / iw, rh / ih)            user_scale = max(0.1, min(2.0, layout.frame_scale_pct / 100.0))            s = fit_scale * user_scale            new_w = max(1, int(iw * s))            new_h = max(1, int(ih * s))            return im.resize((new_w, new_h), Image.LANCZOS)    # Iterate pages    frames_iter = iter(frames)    while True:        page_img = Image.new('RGB', (W, H), color=bg_rgb)        draw = ImageDraw.Draw(page_img)        # Draw tab strip        if layout.tab_side == 'left':            draw.rectangle([margin_px - tab_px, margin_px, margin_px, H - margin_px], fill=bg_rgb)        elif layout.tab_side == 'right':            draw.rectangle([W - margin_px, margin_px, W - margin_px + tab_px, H - margin_px], fill=bg_rgb)        elif layout.tab_side == 'top':            draw.rectangle([margin_px, margin_px - tab_px, W - margin_px, margin_px], fill=bg_rgb)        elif layout.tab_side == 'bottom':            draw.rectangle([margin_px, H - margin_px, W - margin_px, H - margin_px + tab_px], fill=bg_rgb)        placed_any = False        for r in range(rows):            for c in range(cols):                try:                    frame = next(frames_iter)                except StopIteration:                    if not placed_any:                        return page_images                    else:                        page_images.append(page_img)                        return page_images                placed_any = True                # Cell bounds                y0, y1 = row_bounds[r]                x0, x1 = col_bounds[c]                # Per-frame cutting box inside cell                fm = mm_to_px(layout.frame_margin_mm, page.dpi)                fbind = mm_to_px(layout.frame_binding_extra_mm, page.dpi)                left_cut = x0 + fm + (fbind if layout.tab_side == 'left' else 0)                right_cut = x1 - fm - (fbind if layout.tab_side == 'right' else 0)                top_cut = y0 + fm + (fbind if layout.tab_side == 'top' else 0)                bottom_cut = y1 - fm - (fbind if layout.tab_side == 'bottom' else 0)                # Guard                if right_cut <= left_cut or bottom_cut <= top_cut:                    continue                # Inner box size                rw, rh = right_cut - left_cut, bottom_cut - top_cut                # Cut marks (around frame cut box)                if layout.show_cut_marks:                    L = mm_to_px(layout.cut_mark_len_mm, page.dpi)                    off = mm_to_px(layout.cut_mark_offset_mm, page.dpi)                    w = max(1, layout.cut_mark_width_px)                    # Top                    draw.line([(left_cut, top_cut - off), (left_cut + L, top_cut - off)], fill=(0, 0, 0), width=w)                    draw.line([(right_cut - L, top_cut - off), (right_cut, top_cut - off)], fill=(0, 0, 0), width=w)                    # Bottom                    draw.line([(left_cut, bottom_cut + off), (left_cut + L, bottom_cut + off)], fill=(0, 0, 0), width=w)                    draw.line([(right_cut - L, bottom_cut + off), (right_cut, bottom_cut + off)], fill=(0, 0, 0), width=w)                    # Left                    draw.line([(left_cut - off, top_cut), (left_cut - off, top_cut + L)], fill=(0, 0, 0), width=w)                    draw.line([(left_cut - off, bottom_cut - L), (left_cut - off, bottom_cut)], fill=(0, 0, 0), width=w)                    # Right                    draw.line([(right_cut + off, top_cut), (right_cut + off, top_cut + L)], fill=(0, 0, 0), width=w)                    draw.line([(right_cut + off, bottom_cut - L), (right_cut + off, bottom_cut)], fill=(0, 0, 0), width=w)                # Scale and place image                fr = scale_to_inner_box(frame, rw, rh)                fw, fh = fr.size                # Binding-aware alignment: flush opposite bound side                if layout.tab_side == 'left':                    paste_x = right_cut - fw                    paste_y = top_cut + (rh - fh) // 2                elif layout.tab_side == 'right':                    paste_x = left_cut                    paste_y = top_cut + (rh - fh) // 2                elif layout.tab_side == 'top':                    paste_x = left_cut + (rw - fw) // 2                    paste_y = bottom_cut - fh                elif layout.tab_side == 'bottom':                    paste_x = left_cut + (rw - fw) // 2                    paste_y = top_cut                else:                    paste_x = left_cut + (rw - fw) // 2                    paste_y = top_cut + (rh - fh) // 2                # Paste with crop to inner box if overflow                if fw > rw or fh > rh or layout.lock_original_scale:                    fx0, fy0, fx1, fy1 = paste_x, paste_y, paste_x + fw, paste_y + fh                    ox0, oy0 = max(fx0, left_cut), max(fy0, top_cut)                    ox1, oy1 = min(fx1, right_cut), min(fy1, bottom_cut)                    if ox1 > ox0 and oy1 > oy0:                        src_x0, src_y0 = ox0 - fx0, oy0 - fy0                        src_x1, src_y1 = src_x0 + (ox1 - ox0), src_y0 + (oy1 - oy0)                        fr_cropped = fr.crop((src_x0, src_y0, src_x1, src_y1)).convert('RGB')                        page_img.paste(fr_cropped, (ox0, oy0))                else:                    page_img.paste(fr.convert('RGB'), (paste_x, paste_y))                # Optional number                if layout.draw_numbers:                    try:                        font = ImageFont.load_default()                    except Exception:                        font = None                    label = str(len(page_images) * (rows * cols) + r * cols + c + 1)                    tx = right_cut - 6                    ty = bottom_cut - 12                    draw.text((tx + 1, ty + 1), label, fill=(255, 255, 255), anchor='rs', font=font)                    draw.text((tx, ty), label, fill=(0, 0, 0), anchor='rs', font=font)                # Borders (on top)                border_rgb = hex_to_rgb(layout.border_color_hex)                if layout.show_frame_border:                    draw.rectangle([left_cut, top_cut, right_cut, bottom_cut],                                   outline=border_rgb, width=max(1, layout.border_width_px))                if layout.show_cell_border or layout.draw_guides:                    draw.rectangle([x0, y0, x1, y1], outline=border_rgb, width=1)        page_images.append(page_img)# ------------------------------- PDF & ZIP ------------------------------- #def build_pdf(pages: List[Image.Image], page: PageSpec) -> bytes:    buf = io.BytesIO()    c = pdf_canvas.Canvas(buf, pagesize=page.pagesize_pts)    for p in pages:        img_buf = io.BytesIO()        p.save(img_buf, format='PNG')        img_buf.seek(0)        from reportlab.lib.utils import ImageReader        c.drawImage(ImageReader(img_buf), 0, 0,                    width=page.pagesize_pts[0], height=page.pagesize_pts[1])        c.showPage()    c.save()    buf.seek(0)    return buf.read()def zip_frames(frames: List[Image.Image]) -> bytes:    mem = io.BytesIO()    with zipfile.ZipFile(mem, mode='w', compression=zipfile.ZIP_DEFLATED) as zf:        for i, fr in enumerate(frames):            img_bytes = io.BytesIO()            fr.save(img_bytes, format='PNG')            zf.writestr(f'frame_{i:04d}.png', img_bytes.getvalue())    mem.seek(0)    return mem.read()def zip_pages(pages: List[Image.Image]) -> bytes:    mem = io.BytesIO()    with zipfile.ZipFile(mem, mode='w', compression=zipfile.ZIP_DEFLATED) as zf:        for i, pg in enumerate(pages):            img_bytes = io.BytesIO()            pg.save(img_bytes, format='PNG')            zf.writestr(f'page_{i:03d}.png', img_bytes.getvalue())    mem.seek(0)    return mem.read()# ------------------------------- Streamlit UI ---------------------------- #def main():    st.set_page_config(page_title="Print-a-GIF (Version C+)", layout="wide")    st.title("ðŸ–¨ï¸ Printâ€‘aâ€‘GIF â€” Flipbook Maker (Version C+)")    st.caption("Even grid like C + Row layout mode. Per-frame cut box with binding offset.")    with st.sidebar:        st.header("1) GIF Input")        file = st.file_uploader("Choose a GIF", type=["gif"])        unopt = st.checkbox("Unoptimise first (coalesce frames)", value=False,                            help="Fixes many 'optimised' GIFs where later frames only store differences.")        st.header("2) Frame Selection")        c1, c2, c3 = st.columns(3)        with c1:            start = st.number_input("Start frame (0-based)", min_value=0, value=0, step=1)        with c2:            end = st.number_input("End frame (exclusive, -1 for all)", min_value=-1, value=-1, step=1)        with c3:            step = st.number_input("Step (every Nth)", min_value=1, value=1, step=1)        st.header("3) Page & Output")        dpi = st.slider("DPI", min_value=150, max_value=600, value=300, step=25)        page_size_opt = st.selectbox("Page size", ["A4 (210Ã—297 mm)", "Custom (mm)"])        orientation = st.selectbox("Orientation", ["portrait", "landscape"], index=0)        if page_size_opt.startswith("A4"):            page_spec = PageSpec(width_mm=210.0, height_mm=297.0, orientation=orientation, dpi=dpi)        else:            wmm = st.number_input("Width (mm)", min_value=50.0, max_value=2000.0, value=210.0, step=1.0)            hmm = st.number_input("Height (mm)", min_value=50.0, max_value=2000.0, value=297.0, step=1.0)            page_spec = PageSpec(width_mm=wmm, height_mm=hmm, orientation=orientation, dpi=dpi)        st.header("4) Layout")        cols = st.number_input("Columns (frames per row)", min_value=1, max_value=12, value=3, step=1)        rows = st.number_input("Rows per page", min_value=1, max_value=40, value=3, step=1)        margin = st.number_input("Outer page margin (mm)", min_value=0.0, max_value=50.0, value=5.0, step=0.5)        spacing = st.number_input("Cell spacing / gutter (mm)", min_value=0.0, max_value=20.0, value=1.5, step=0.5)        tab_width = st.number_input("Page binding tab width (mm)", min_value=0.0, max_value=50.0, value=0.0, step=0.5)        tab_side = st.selectbox("Binding side (per-frame & page)", ["left", "right", "top", "bottom", "none"], index=0)        spacing_color = st.color_picker("Spacing/background color", value="#FFFF00")        draw_guides = st.checkbox("Draw cell outlines (debug)", value=False)        draw_numbers = st.checkbox("Frame numbers", value=False)        st.subheader("Row layout mode")        mode = st.selectbox(            "Mode",            ["Fixed columns (no auto-scale)", "Fit N per row (auto)"] ,            index=0,            help="Auto mode fits images into the inner cut box exactly (ignores Lock Original & Scale%)."        )        lock_original = st.checkbox("Lock original scale (100%)", value=False)        scale_pct = st.slider("Frame scale (%)", min_value=10, max_value=200, value=100, step=5,                              help="Ignored in auto-fit mode.")        st.subheader("Per-frame cutting box")        frame_margin = st.number_input("Cutting margin (mm) â€” all sides", min_value=0.0, max_value=30.0, value=3.0, step=0.5)        frame_bind_extra = st.number_input("Binding extra on bound side (mm)", min_value=0.0, max_value=30.0, value=3.0, step=0.5)        st.subheader("Cut marks")        show_cuts = st.checkbox("Show cut marks", value=True)        cut_len = st.number_input("Mark length (mm)", min_value=1.0, max_value=20.0, value=4.0, step=0.5)        cut_off = st.number_input("Mark offset from edge (mm)", min_value=0.0, max_value=10.0, value=0.0, step=0.5)        cut_w = st.number_input("Mark line width (px)", min_value=1, max_value=5, value=1, step=1)        st.subheader("Borders")        border_mode = st.selectbox(            "Border mode",            ["None", "Frame box (cut area)", "Cell box (grid cell)", "Both"],            index=1,            help="Choose which borders to draw on top of frames."        )        border_color = st.color_picker("Border color", value="#000000")        border_width = st.number_input("Frame border width (px)", min_value=1, max_value=8, value=1, step=1)    if file is None:        st.info("Upload a GIF to begin.")        return    # Build frames    frames = extract_gif_frames(file.read(), unoptimize=unopt)    total = len(frames)    # Selection    end_eff = total if (end == -1 or end > total) else end    sel_idx = list(range(start, end_eff, step))    frames_sel = [frames[i] for i in sel_idx if 0 <= i < total]    layout = LayoutParams(        cols=int(cols),        rows=int(rows),        print_margin_mm=float(margin),        cut_spacing_mm=float(spacing),        tab_width_mm=float(tab_width),        tab_side=tab_side,        spacing_hex=spacing_color,        draw_guides=bool(draw_guides),        draw_numbers=bool(draw_numbers),        number_font_size_pt=8,        lock_original_scale=bool(lock_original),        frame_scale_pct=int(scale_pct),        frame_margin_mm=float(frame_margin),        frame_binding_extra_mm=float(frame_bind_extra),        show_cut_marks=bool(show_cuts),        cut_mark_len_mm=float(cut_len),        cut_mark_offset_mm=float(cut_off),        cut_mark_width_px=int(cut_w),        show_frame_border=(border_mode in ("Frame box (cut area)", "Both")),        show_cell_border=(border_mode in ("Cell box (grid cell)", "Both")),        border_color_hex=border_color,        border_width_px=int(border_width),        fit_to_columns=(mode == "Fit N per row (auto)"),    )    # Compose    page_spec = page_spec  # already picked above    pages = compose_pages(frames_sel, page_spec, layout)    # Preview    st.subheader("Preview")    if pages:        preview = pages[0].copy()        preview_w = min(900, preview.size[0])        scale = preview_w / preview.size[0]        preview = preview.resize((int(preview.size[0] * scale), int(preview.size[1] * scale)), Image.BILINEAR)        st.image(preview, caption=f"Page 1 of {len(pages)} (preview)")    else:        st.warning("No pages produced. Check frame selection and layout settings.")        return    # Export    st.subheader("Export")    pdf_bytes = build_pdf(pages, page_spec)    frames_zip = zip_frames(frames_sel)    pages_zip = zip_pages(pages)    c1, c2, c3 = st.columns(3)    with c1:        st.download_button("â¬‡ï¸ Download PDF", data=pdf_bytes, file_name="print_a_gif_vCplus.pdf", mime="application/pdf")    with c2:        st.download_button("â¬‡ï¸ Frames (ZIP)", data=frames_zip, file_name="frames.zip", mime="application/zip")    with c3:        st.download_button("â¬‡ï¸ Pages as PNG (ZIP)", data=pages_zip, file_name="pages.zip", mime="application/zip")    st.caption(        f"Frames used: {len(frames_sel)} â€¢ Pages: {len(pages)} â€¢ Grid: {layout.cols}Ã—{layout.rows} â€¢ DPI: {page_spec.dpi} â€¢ Page: {page_spec.width_mm:.0f}Ã—{page_spec.height_mm:.0f} mm ({page_spec.orientation})"    )if __name__ == "__main__":    main()